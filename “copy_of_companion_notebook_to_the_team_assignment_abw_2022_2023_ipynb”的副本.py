# -*- coding: utf-8 -*-
"""“Copy of Companion notebook to the team assignment ABW 2022/2023.ipynb”的副本

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16MccC3WnM0R2GegkPLyo14kVZFkzNojq

# Python<img src='https://developers.redhat.com/sites/default/files/styles/article_feature/public/blog/2014/09/python-logo.png?itok=NNQ6xBcf' align='after' width=180> for <img align='after' width='180' src='https://drive.google.com/uc?export=view&id=19qZe5VIxkIEm7_hYkrvlH142XPBxBaEf'> 
 # Data manipulations for a possible resolution of the team assignment


---
> This notebook processes the data from the excel sheet from [canvas](https://canvas.uva.nl/courses/25016/files/folder/Tutorials/Data) in order to obtain the information that you may need to solve the team Assignment 1. Feel free to make a copy of this notebook and add the code of your resolution to it. 
---
"""

import sys
if 'google.colab' in sys.modules:
    import os
    from google.colab import files
    # just check if we already uploaded, may we restart the runtime and run all cells
    if not os.path.isfile('Data Set Feedcalculator.xlsx'):
        uploaded = files.upload()

"""# Read the data, as you have already seen [here]( https://colab.research.google.com/drive/1Q3fNgpa8QfGTzJ7lj-oZ8Ya0IIGCdnEr)."""

import pandas as pd
import sys
import shutil
!pip install pyomo
from pyomo.environ import *
data = pd.read_excel('Data Set Feedcalculator.xlsx',sheet_name=None)

at_colab = "google.colab" in sys.modules
if at_colab:
    if not shutil.which('/usr/bin/glpsol'):
        !sudo apt install libglpk-dev python3.8-dev libgmp3-dev
        !apt-get install -y -qq glpk-utils
        assert(shutil.which('/usr/bin/glpsol'))

ingredients      = data['Ingredient Database']
nutrient_rules   = data['Nutrient Rules']
ingredient_rules = data['Ingredient Rules']

"""# Collect the ingredients that are available together with the relevant columns"""

available_ingredients = ingredients[ingredients.Availability][['Name','Reference name','Price']+list(nutrient_rules.Nutrient)].set_index('Reference name')
available_ingredients

"""# Collect the nutrient bounds

Note that 'not available' in a data frame is not the same as None!
"""

nutrient_bounds = { nut : (lb if not pd.isna(lb) else 0,     # no lower bound translates into 0 as lower bound
                           ub if not pd.isna(ub) else None)  # no upper bound becomes None
                    for nut,lb,ub in zip(nutrient_rules.Nutrient,nutrient_rules['Lower Bound'],nutrient_rules['Upper Bound']) 
                  }

nutrient_bounds

"""# Collect the ingredient bounds

Note again that 'not available' in a data frame is not the same as None!
"""

ingredient_bounds = { ing : (lb if not pd.isna(lb) else 0,    # no lower bound translates into 0 as lower bound
                             ub if not pd.isna(ub) else None) # no upper bound becomes None
                      for ing,lb,ub in zip(ingredient_rules.Ingredient,ingredient_rules['Lower Bound'],ingredient_rules['Upper Bound']) }

ingredient_bounds

"""# Collect the combined ingredient rules

This is slightly more complex, as we need to know where this data is placed in the sheet, hence the data frame. 
Note how we use `.dropna()` on series to leave only the values defined. 
Note as well how we filter the ingredients that are not available. 
It may happen that a combined rule disappears, because it did only relate to not available ingredients. 

If you want to know where the `Unnamed: ` columns are comming from, just examine the `ingredient_rules` data frame. 

"""

combined_ingredient_rules   = [] 
set_of_availabe_ingredients = set(available_ingredients.index)
for c in ['Unnamed: '+str(i) for i in range(5,13)]:
    aux = ingredient_rules[[c]].dropna().values
    aux = [ v[0] for v in aux ]
    upperbound          = aux[0]
    ingredients_in_rule = set(aux[1:]).intersection(set_of_availabe_ingredients)
    if ingredients_in_rule:
        combined_ingredient_rules.append((upperbound,ingredients_in_rule))
combined_ingredient_rules

nutrients = nutrient_bounds.keys()
for nutrient in nutrients:
  print(nutrient_bounds[nutrient][1])

# Linear Optimization Model
# Define Model
def question1():
  model = ConcreteModel()
  # Set of Possible Ingredient
  model.ingredient = Set(initialize = available_ingredients.index)
  model.nutrients = Set(initialize = nutrients)
  # Indexed Variable of optimized amount of available Ingredient
  model.x = Var(model.ingredient,domain = NonNegativeReals)

  # Total Ingredient Constraint
  model.total = Constraint(expr = sum(model.x[name] for name in model.ingredient) == 1)

  # Constraint of ingredient bounds
  model.ingredient_bounds_lower = ConstraintList()
  for name in model.ingredient:
    if name in ingredient_bounds.keys():
      model.ingredient_bounds_lower.add(expr = model.x[name] >= ingredient_bounds[name][0])
  model.ingredient_bounds_upper = ConstraintList()
  for name in model.ingredient:
    if name in ingredient_bounds.keys() and ingredient_bounds[name][1] != None:
      model.ingredient_bounds_upper.add(expr = model.x[name] <= ingredient_bounds[name][1])

  # Constraint of nutrient bounds
  def nutrient_bounds_upper_rule(model, nutrient):
    return sum(model.x[name]*available_ingredients.loc[name, nutrient] for name in model.ingredient)<= nutrient_bounds[nutrient][1]
  model.nutrient_bounds_upper = Constraint(model.nutrients, rule=nutrient_bounds_upper_rule)

  def nutrient_bounds_lower_rule(model, nutrient):
    return sum(model.x[name]*available_ingredients.loc[name, nutrient] for name in model.ingredient)>= nutrient_bounds[nutrient][0]
  model.nutrient_bounds_lower = Constraint(model.nutrients, rule=nutrient_bounds_lower_rule)

  # Combined Ingredient
  model.combined_ingredient = ConstraintList()
  for i in combined_ingredient_rules:
    model.combined_ingredient.add(expr = sum(model.x[j] for j in i[1])<=i[0])

  # Objective to reduce Cost
  model.cost_minimise = Objective( expr = sum(available_ingredients.loc[name,'Price'] * model.x[name] \
                    for name in model.ingredient), sense = minimize)
  return model 
#Solving
kk = question1()
results = SolverFactory('glpk').solve(kk)
print(kk.cost_minimise())